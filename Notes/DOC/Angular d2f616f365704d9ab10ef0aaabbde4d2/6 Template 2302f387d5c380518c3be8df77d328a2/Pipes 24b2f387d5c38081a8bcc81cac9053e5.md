# Pipes

## Descripción general

Los *pipes* (tuberías) son un operador especial en las expresiones de plantilla de Angular que te permite transformar datos de forma declarativa directamente en tu plantilla.

Con los pipes puedes declarar una función de transformación una sola vez y reutilizarla en múltiples plantillas.

Angular utiliza el carácter de barra vertical (`|`), inspirado en el *pipe* de Unix.

> Nota: La sintaxis de pipe de Angular difiere de la de JavaScript estándar, donde la barra vertical (|) se usa para el operador bit a bit OR.
> 
> 
> Las expresiones de plantilla de Angular **no** admiten operadores bit a bit.
> 

Ejemplo usando algunos *pipes* integrados que ofrece Angular:

```tsx

import { Component } from '@angular/core';
import { CurrencyPipe, DatePipe, TitleCasePipe } from '@angular/common';

@Component({
  selector: 'app-root',
  imports: [CurrencyPipe, DatePipe, TitleCasePipe],
  template: `
    <main>
       <!-- Transforma el nombre de la compañía a "title case" y
       transforma la fecha purchasedOn a un formato localizado -->
       <h1>Compras de {{ company | titlecase }} el {{ purchasedOn | date }}</h1>

       <!-- Transforma el importe a un formato de moneda -->
       <p>Total: {{ amount | currency }}</p>
    </main>
  `,
})
export class ShoppingCartComponent {
  amount = 123.45;
  company = 'acme corporation';
  purchasedOn = '2024-07-08';
}

```

Cuando Angular renderiza el componente, se asegura de que el formato de fecha y de moneda sea el apropiado según la configuración regional (locale) del usuario.

Si el usuario está en Estados Unidos, el resultado sería:

```html

<main>
  <h1>Purchases from Acme Corporation on Jul 8, 2024</h1>
  <p>Total: $123.45</p>
</main>

```

Consulta la guía detallada sobre **i18n** para aprender más sobre cómo Angular localiza valores.

---

## Pipes integrados

Angular incluye un conjunto de *pipes* integrados en el paquete `@angular/common`:

| Nombre | Descripción |
| --- | --- |
| **AsyncPipe** | Lee el valor de una *Promise* o un *Observable* de RxJS. |
| **CurrencyPipe** | Transforma un número en una cadena con formato de moneda, según las reglas de la configuración regional. |
| **DatePipe** | Formatea un valor *Date* según las reglas de la configuración regional. |
| **DecimalPipe** | Transforma un número en una cadena con punto decimal, formateada según las reglas de la configuración regional. |
| **I18nPluralPipe** | Mapea un valor a una cadena que pluraliza el texto según las reglas de la configuración regional. |
| **I18nSelectPipe** | Mapea una clave a un selector personalizado que devuelve un valor específico. |
| **JsonPipe** | Transforma un objeto en una representación de cadena usando `JSON.stringify`, pensado para depuración. |
| **KeyValuePipe** | Transforma un *Object* o *Map* en un array de pares clave-valor. |
| **LowerCasePipe** | Convierte texto a minúsculas. |
| **PercentPipe** | Transforma un número en una cadena con formato de porcentaje, según las reglas de la configuración regional. |
| **SlicePipe** | Crea un nuevo *Array* o *String* que contiene un subconjunto (slice) de los elementos. |
| **TitleCasePipe** | Convierte texto a *Title Case* (capitaliza la primera letra de cada palabra). |
| **UpperCasePipe** | Convierte texto a mayúsculas. |

---

## Uso de pipes

El operador de pipe de Angular usa el carácter barra vertical (`|`) dentro de una expresión de plantilla.

Es un operador binario:

- El operando de la izquierda es el valor que se pasa a la función de transformación.
- El operando de la derecha es el nombre del pipe y cualquier argumento adicional (explicado más adelante).

Ejemplo:

```html

<p>Total: {{ amount | currency }}</p>

```

Aquí, el valor de `amount` se pasa a **CurrencyPipe** (nombre del pipe: `currency`), que lo renderiza en la moneda predeterminada para la configuración regional del usuario.

---

## Combinando varios pipes en la misma expresión

Puedes aplicar múltiples transformaciones a un valor usando varios operadores de pipe.

Angular ejecuta los pipes **de izquierda a derecha**.

Ejemplo para mostrar una fecha localizada en mayúsculas:

```html

<p>El evento ocurrirá el {{ scheduledOn | date | uppercase }}.</p>

```

---

## Pasando parámetros a un pipe

Algunos pipes aceptan parámetros para configurar la transformación.

Para especificar un parámetro, añade el nombre del pipe seguido de dos puntos (`:`) y el valor del parámetro.

Ejemplo con **DatePipe** para mostrar solo la hora:

```html

<p>El evento ocurrirá a las {{ scheduledOn | date:'hh:mm' }}.</p>

```

Algunos pipes aceptan múltiples parámetros.

Se pueden pasar separados por dos puntos (`:`).

Ejemplo con **DatePipe** especificando también la zona horaria:

```html

<p>El evento ocurrirá a las {{ scheduledOn | date:'hh:mm':'UTC' }}.</p>

```

---

## Cómo funcionan los pipes

Conceptualmente, los *pipes* son funciones que reciben un valor de entrada y devuelven un valor transformado.

```tsx

import { Component } from '@angular/core';
import { CurrencyPipe } from '@angular/common';

@Component({
  selector: 'app-root',
  imports: [CurrencyPipe],
  template: `
    <main>
      <p>Total: {{ amount | currency }}</p>
    </main>
  `,
})
export class AppComponent {
  amount = 123.45;
}

```

En este ejemplo:

- **CurrencyPipe** se importa desde `@angular/common`.
- **CurrencyPipe** se añade al array `imports`.
- El dato `amount` se pasa al *currency pipe*.

---

## Precedencia del operador de pipe

El operador de pipe tiene **menor precedencia** que otros operadores binarios, incluyendo `+`, `-`, `*`, `/`, `%`, `&&`, `||` y `??`.

```html

<!-- firstName y lastName se concatenan antes de pasar el resultado al pipe uppercase -->
{{ firstName + lastName | uppercase }}

```

El operador de pipe tiene **mayor precedencia** que el operador condicional (ternario):

```html

{{ (isAdmin ? 'Access granted' : 'Access denied') | uppercase }}

```

Si la misma expresión se escribiera sin paréntesis:

```html

{{ isAdmin ? 'Access granted' : 'Access denied' | uppercase }}

```

Se interpretaría como:

```html

{{ isAdmin ? 'Access granted' : ('Access denied' | uppercase) }}

```

**Siempre** usa paréntesis en tus expresiones cuando la precedencia de operadores pueda ser ambigua.

---

## Detección de cambios con pipes

Por defecto, todos los pipes se consideran **puros**, lo que significa que solo se ejecutan cuando:

- Un valor primitivo (como `String`, `Number`, `Boolean` o `Symbol`) cambia.
- Una referencia de objeto (como `Array`, `Object`, `Function` o `Date`) cambia.

Los pipes puros ofrecen una ventaja de rendimiento, porque Angular evita llamar a la función de transformación si el valor pasado no ha cambiado.

Esto implica que las **mutaciones** a propiedades de objetos o elementos de arrays **no** se detectan, a menos que se reemplace toda la referencia del objeto o array por una instancia diferente.

Si quieres este nivel de detección de cambios, revisa la sección *Detectar cambios dentro de arrays u objetos*.

---

## Creando pipes personalizados

Puedes definir un pipe personalizado implementando una clase TypeScript con el decorador `@Pipe`.

Un pipe debe tener dos cosas:

1. **Un nombre**, especificado en el decorador `@Pipe`.
2. **Un método `transform`** que realice la transformación del valor.

La clase TypeScript también debería implementar la interfaz `PipeTransform` para garantizar que cumple con la firma de tipo de un pipe.

Ejemplo de un pipe personalizado que transforma cadenas a *kebab-case*:

```tsx

// kebab-case.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'kebabCase',
})
export class KebabCasePipe implements PipeTransform {
  transform(value: string): string {
    return value.toLowerCase().replace(/ /g, '-');
  }
}

```

---

## Uso del decorador @Pipe

Cuando creas un pipe personalizado, importa `Pipe` desde `@angular/core` y úsalo como decorador de la clase TypeScript.

```tsx

import { Pipe } from '@angular/core';

@Pipe({
  name: 'myCustomTransformation',
})
export class MyCustomTransformationPipe {}

```

El decorador `@Pipe` requiere un **nombre**, que es cómo se usará el pipe en la plantilla.

---

## Convenciones de nombres para pipes personalizados

La convención de nombres para pipes personalizados sigue dos reglas:

- **name**: se recomienda *camelCase*. No uses guiones.
- **class name**: la versión *PascalCase* del nombre, con `Pipe` al final.

---

## Implementando la interfaz PipeTransform

Además del decorador `@Pipe`, los pipes personalizados deben **siempre** implementar la interfaz `PipeTransform` de `@angular/core`.

```tsx

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'myCustomTransformation',
})
export class MyCustomTransformationPipe implements PipeTransform {}

```

Implementar esta interfaz garantiza que tu clase de pipe tenga la estructura correcta.

---

## Transformando el valor en un pipe

Cada transformación se invoca mediante el método `transform`, donde:

- El **primer parámetro** es el valor recibido.
- El **valor de retorno** es el resultado transformado.

```tsx

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'myCustomTransformation',
})
export class MyCustomTransformationPipe implements PipeTransform {
  transform(value: string): string {
    return `Mi transformación personalizada de ${value}.`
  }
}

```

---

## Añadiendo parámetros a un pipe personalizado

Puedes añadir parámetros a tu transformación agregando argumentos adicionales al método `transform`:

```tsx

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'myCustomTransformation',
})
export class MyCustomTransformationPipe implements PipeTransform {
  transform(value: string, format: string): string {
    let msg = `Mi transformación personalizada de ${value}.`
    if (format === 'uppercase') {
      return msg.toUpperCase()
    } else {
      return msg
    }
  }
}

```

---

## Detectar cambios dentro de arrays u objetos

Si quieres que un pipe detecte cambios **dentro** de arrays u objetos, debes marcarlo como una función **impura** pasando la propiedad `pure` con valor `false`.

> ⚠️ Evita crear pipes impuros a menos que sea absolutamente necesario, ya que pueden generar un alto coste de rendimiento si se usan sin cuidado.
> 

```tsx

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'joinNamesImpure',
  pure: false,
})
export class JoinNamesImpurePipe implements PipeTransform {
  transform(names: string[]): string {
    return names.join();
  }
}

```

Los desarrolladores de Angular suelen adoptar la convención de incluir la palabra **Impure** en el nombre del pipe y de la clase, para advertir a otros desarrolladores del posible impacto en el rendimiento.